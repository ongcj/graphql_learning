# Core Concepts

## Schema Definition Language
GraphQL has its own type system that is used to define the schema of an API. The syntax for writing schema is called the schema definition language (STL).

### Types
Example to define 2 simple types: 
```
type Person {
    name: String!
    age: Int!
}
```
Person type has 2 fields, name and age, with type string and int respectively. The exclamation point (!) following the type means this field is **required**. 
```
type Post {
    title: String!
}
```
Post only has one field, title, and is of type string.

### Relation
It is also possible to add relationships between types, which is called relation is GraphQL. 

Example to define a relation:
To express that one person can be the author of many posts,

**First**, add the author field to the Post type. 
```
type Post {
    title: String!
    author: Person!
}
```

This indicates that every post that is created must be associated to a person, who is the author of it. 

**Second**, add the post field to the Person type to express that a person can write multiple posts. 
```
type Person {
    name: String!
    age: Int!
    posts: [Post!]!
}
```
The syntax to specific the list in SDL is through the use of square brackets ([]). This is defined as a one-to-many relationship between Person and Post type.

## Fetching Data with Queries
Data requirement of a client are encoded in the URL that it connects to. Instead of having multiple endpoints that returns fixed data structures, GraphQL API only expose a single endpoint.

### Queries
Only a single endpoint work since the client needs to decide what information is needed through queries to express its data needs. 

```
{
    allPersons {
        name
    }
}
```

The allPersons field is called the root field of the query. And everything that follows the root field is called the payload of the query. The above query will return a list of Person that are currently stored in the database. An example response is below. 

```json
{
  "allPersons": [
    {"name": "Johnny"},
    {"name": "Sarah"},
    {"name": "Alic"}
  ]
}
```
Note that each person only has name in the response, and age is not returned by the server. That is because that name was the only field that was specified in the query payload.

If the client also need the person age, all it needs to do is to slightly adjust the query in the payload as shown below.

```
{
    allPersons {
        name
        age
    }
}
```
The response would then be 
```json
{
  "allPersons": [
    {"name": "Johnny", "age":  23},
    {"name": "Sarah", "age":  20},
    {"name": "Alic", "age":  20}
  ]
}
```

It can also indicate the number of rows to be return by specifying parameter in the query shown below.
```
{
    allPersons(last: 2) {
        name
        age
    }
}
```
With the above query, the server will only return the last 2 person that have been stored in the database. 
```json
{
  "allPersons": [
    {"name": "Sarah", "age":  20},
    {"name": "Alic", "age":  20}
  ]
}
```

### Nested Queries

GraphQL query also supports nested information. The below is a query to load all the post of each person as additional information by following the structure of the type.
```
{
    allPersons {
        name
            posts {
                title
            }
    }
}
```
The server will resolve this query and include the list of posts that are associated with each person shown below.
```json
{
  "allPersons": [
    {
         "name": "Johnny",
         "posts": [
            {"title":  "asdasd"},
            {"title":  "asdasd123123"}
         ]
    },
    {
         "name": "Sarah",
         "posts":  ["zxczxc"]
    },
    {
         "name": "Alic",
         "posts": [
            {"title":  "qwe"}
         ] 
}
  ]
}
```

### Mutation
3 types of mutations:
1. Creating new data
2. Updating existing data
3. Deleting existing data

Mutation generally follows the same technical structure as queries. It needs to start with the `mutation` keyword. 

#### Create
```
mutation {
    createPerson(name: "Bob", age: 36) {
        id
    }
}
```
Similar to query, mutation also has a `root` field, which in this case is `createPerson`. CreatePerson takes 2 arguments that specify the new person name and age. Like a query, it is also able to specify a payload for mutation in which can ask for different properties of the new person object. 

GraphQL types have unique IDs that are generated by the server. When the person is create with the above mutation, it can directly ask for the `id` in the payload shown above.

## Realtime Updates with Subscription
When a client subscript to an event, it will hold a steady connection to the server. One subscript example is below.

```
subscription {
    newPerson {
        name
        age
    }
}
```
The client will get informed about new users being created. When the event happened, the server will push the corresponding data to the client.

Unlike queries and mutation that follows a request response cycle, subscription is a stream of data sent over to the client. 

## Schema
Schema specifies the capability of the API by indicating how a client can fetch and update data. It is often seen as a contract between the server and the client. 

A schema is simply a collection of GraphQL types. Each schema will have either Query, Mutation or Subscription (root types) types that define the entry point of the API.

### Query Type
To enable the all person query used in the beginning, 
```
type Query {
    allPersons(last:Int) : [Person!]!
}
```
The query will return a list of Person.

### Mutation Type
For the mutation to create a new person, it is required to add the createPerson field to the mutation type since that is the root field that is used when sending the mutation.
```
type Mutation {
    createPerson(name: String!, age: String!): Person!
}
```
It takes the name and age argument to create Person, and the return type is Person type. The returned Person is the one created by the mutation.

### Subscription Type
```
type Scubscription {
    newPerson: Person!
}
```

### CRUD 
We can implement more API so that it can achieve CRUD. In the above example, creation and reading of person is done. 

To have update and delete, simply add to the Mutation type.
```
type Mutation {
    createPerson(name: String!, age: String!): Person! 
    updatePerson(id:ID!, name: String!, age: String!): Person!
    deletePerson(id:ID!): Person!
}
```
Update person mutation takes in the id to specify which Person to update, and the properties to be updated to as argument. Delete person mutation only requires id to specify which Person to delete.

